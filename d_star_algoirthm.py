# -*- coding: utf-8 -*-
"""Research_Implementation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vEsYDPvN0y479NxFeinc38MmSKFnn43u
"""

import heapq
import math
import random
from typing import List, Tuple, Set, Dict, Optional

class Cell:
  def __init__(self, x: int, y: int):
    self.x = x
    self.y = y
    self.cost = float("inf") # cost to reach this cell from start
    self.estimate = float("inf") # Heuristic estimate to goal
    self.parent: Optional["Cell"] = None

  def __lt__(self, other):
    # For priority queue: compare by cost + estimate (f-score)
    return (self.cost + self.estimate) < (other.cost + other.estimate)

  def __eq__(self, other):
    if other is None:
        return False
    return self.x == other.x and self.y == other.y

  def __hash__(self):
    return hash((self.x, self.y))

  def __repr__(self):
    return f"Cell({self.x}, {self.y})"

class DStarPathPlanner:
    def __init__(self, grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]):
        """
        Initialize D* path planner

        Args:
            grid: 2D grid where 0 = free space, 1 = obstacle
            start: Starting position (x, y)
            goal: Goal position (x, y)
        """
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0])
        self.start_pos = start
        self.goal_pos = goal

        # Create cell grid
        self.cells: Dict[Tuple[int, int], Cell] = {}
        for i in range(self.rows):
            for j in range(self.cols):
                self.cells[(i, j)] = Cell(i, j)

        self.start = self.cells[start]
        self.goal = self.cells[goal]

        # Open list (priority queue)
        self.open_list: List[Tuple[float, Cell]] = []
        self.open_set: Set[Cell] = set()

        # Initialize algorithm
        self._initialize()

    def _initialize(self):
        """Initialize costs and estimates of all cells except goal"""
        # Line 3: Initialize costs and estimates of all cells except goal
        for cell in self.cells.values():
            cell.cost = float('inf')
            cell.estimate = self.heuristic(cell, self.goal)
            cell.parent = None

        # Line 4: Set cost of goal cell to 0
        self.goal.cost = 0
        self.goal.estimate = 0

        # Line 5: Initialize an empty Open List
        self.open_list = []
        self.open_set = set()

    def heuristic(self, cell1: Cell, cell2: Cell) -> float:
        """Calculate heuristic (Euclidean distance)"""
        dx = cell1.x - cell2.x
        dy = cell1.y - cell2.y
        return math.sqrt(dx * dx + dy * dy)

    def get_neighbors(self, cell: Cell) -> List[Cell]:
        """Get valid neighboring cells (8-connected)"""
        neighbors = []
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0),  (1, 1)
        ]

        for dx, dy in directions:
            nx, ny = cell.x + dx, cell.y + dy

            # Check bounds
            if 0 <= nx < self.rows and 0 <= ny < self.cols:
                # Check if not obstacle
                if self.grid[nx][ny] == 0:
                    neighbors.append(self.cells[(nx, ny)])

        return neighbors

    def movement_cost(self, from_cell: Cell, to_cell: Cell) -> float:
        """Calculate movement cost between adjacent cells"""
        # Diagonal movement costs sqrt(2), straight movement costs 1
        dx = abs(from_cell.x - to_cell.x)
        dy = abs(from_cell.y - to_cell.y)

        if dx + dy == 2:  # Diagonal
            return math.sqrt(2)
        else:  # Straight
            return 1.0

    def add_to_open_list(self, cell: Cell):
        """Add cell to open list"""
        if cell not in self.open_set:
            heapq.heappush(self.open_list, (cell.cost + cell.estimate, cell))
            self.open_set.add(cell)

    def pop_from_open_list(self) -> Optional[Cell]:
        """Remove and return cell with minimum cost from open list"""
        while self.open_list:
            _, cell = heapq.heappop(self.open_list)
            if cell in self.open_set:
                self.open_set.remove(cell)
                return cell
        return None

    def update_costs_and_estimates(self, cell: Cell):
        """Update costs and estimates of neighboring cells (Line 11)"""
        neighbors = self.get_neighbors(cell)

        for neighbor in neighbors:
            # Calculate new potential cost
            new_cost = cell.cost + self.movement_cost(cell, neighbor)

            # If we found a better path to neighbor
            if new_cost < neighbor.cost:
                neighbor.cost = new_cost
                neighbor.parent = cell
                self.add_to_open_list(neighbor)
    
    def process_open_list(self) -> List[Tuple[int, int]]:
        while self.open_list:
            current = self.pop_from_open_list()

            if current is None:
                break

            if current == self.start:
                return self.extract_path()
            
            self.update_costs_and_estimates(current)
        return []

    def plan(self) -> List[Tuple[int, int]]:
        """
        Main D* planning algorithm
        Returns: Optimal path from start to goal as list of (x, y) coordinates
        """
        # Add goal to open list
        self.add_to_open_list(self.goal)

        return self.process_open_list()
    
    def create_random_obstacles(self) -> List[Tuple[int, int]]:
        # random obstacles array 
        random_obstacles = []
        # iterate a number of times
        for _ in range(6):
            randomX = random.randint(0, self.rows - 1)
            randomY = random.randint(0, self.cols - 1)
            if (randomX, randomY) != self.goal_pos and (randomX, randomY) != self.start_pos:
                if self.grid[randomX][randomY] == 0:
                    random_obstacles.append((randomX, randomY))
        
        return random_obstacles

    def detect_changes(self) -> List[Tuple[int, int]]:
        """
        Detect changes in environment (new obstacles)
        Returns: List of cells that changed
        """
        # This would be implemented based on sensor readings
        # For now, it's a placeholder that external code can use
        changed_cells = []
        # Implementation would compare current grid with known grid

        # loop through each row
            # loop through each col
                # if the same coordinate does not match then
                    # add that cell to the changed cells array
        return changed_cells

    def replan(self, changed_cells: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
        """
        Replan when changes are detected in environment

        Args:
            changed_cells: List of (x, y) positions that became obstacles

        Returns: New optimal path from start to goal
        """
        
        # Line 12: if Changes detected in the environment then
        if changed_cells:
            # Line 13: Update costs and estimates accordingly
            for x, y in changed_cells:
                # Mark as obstacle
                self.grid[x][y] = 1

                # Update affected cells
                cell = self.cells[(x, y)]
                cell.cost = float('inf')

                # Re-add neighbors to open list for reconsideration
                neighbors = self.get_neighbors(cell)
                for neighbor in neighbors:
                    if neighbor.parent == cell:
                        neighbor.cost = float('inf')
                        neighbor.parent = None
                    self.add_to_open_list(neighbor)

        # Continue planning from current state
        res = self.process_open_list()
        if not res:
            return self.extract_path()
        return res

    def extract_path(self) -> List[Tuple[int, int]]:
        """
        Extract path from start to goal by following parent pointers
        Returns: Path as list of (x, y) coordinates
        """
        path = []
        current = self.start

        while current is not None:
            path.append((current.x, current.y))
            if current == self.goal:
                break
            current = current.parent

        return path if path and path[-1] == self.goal_pos else []

    def get_dynamic_path(self) -> List[Tuple[int, int]]:
        """
        Line 17: return dynamic path from start to goal
        This is the main entry point for getting a path
        """
        return self.plan()

# Example usage
if __name__ == "__main__":
    # Create a grid (0 = free, 1 = obstacle)
    grid = [
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0]
    ]

    old_grid = [
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0]
    ]

    start = (0, 4)
    goal = (4, 0)

    # Create planner
    planner = DStarPathPlanner(grid, start, goal)

    # Get initial path
    print("Computing initial path...")
    path = planner.get_dynamic_path()
    print(f"Initial path: {path}")
    print(f"Path length: {len(path)}")

    # Simulate discovering new obstacles
    print("\nDiscovering new obstacles...")
    # new_obstacles = [(5, 3), (5, 4), (5, 5)]
    new_obstacles = planner.create_random_obstacles()
    print(f"Coordinates of new obstacles: {new_obstacles}")
    # planner.detect_changes()

    # Update grid and replan
    new_path = planner.replan(new_obstacles)
    print(f"New path after obstacles: {new_path}")
    print(f"New path length: {len(new_path)}")

    # Visualize the path
    def visualize_grid(grid, path):
        """Visualize grid with path"""
        visual = [row[:] for row in grid]  # Copy grid

        for x, y in path:
            if visual[x][y] == 0:
                visual[x][y] = 2  # Mark path

        # Mark start and goal
        if path:
            sx, sy = path[0]
            gx, gy = path[-1]
            visual[sx][sy] = 3  # Start
            visual[gx][gy] = 4  # Goal

        symbols = {0: '·', 1: '█', 2: '*', 3: 'S', 4: 'G'}
        print("\nGrid visualization:")
        print("(· = free, █ = obstacle, * = path, S = start, G = goal)")
        for row in visual:
            print(' '.join(symbols.get(cell, '?') for cell in row))

    visualize_grid(old_grid, path)
    visualize_grid(grid, new_path)